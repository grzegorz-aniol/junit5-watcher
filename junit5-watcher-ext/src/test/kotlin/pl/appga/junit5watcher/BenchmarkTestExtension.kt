package pl.appga.junit5watcher

import java.lang.reflect.InvocationTargetException
import org.junit.jupiter.api.extension.AfterAllCallback
import org.junit.jupiter.api.extension.BeforeAllCallback
import org.junit.jupiter.api.extension.ExtensionContext
import org.junit.jupiter.api.extension.ParameterContext
import org.junit.jupiter.api.extension.ParameterResolver
import org.slf4j.LoggerFactory
import kotlin.reflect.full.companionObject
import kotlin.reflect.full.companionObjectInstance
import kotlin.reflect.full.findAnnotations
import kotlin.reflect.full.valueParameters
import kotlin.time.Duration
import kotlin.time.measureTimedValue

/**
 * Extension to test results generated by BenchmarkExtension.
 *
 * <code>BenchmarkTestExtension</code> should be registered __before_ extension under test
 * - then it doesn't affect results measured by <code>BenchmarkExtension</code>
 *
 */
internal class BenchmarkTestExtension : ParameterResolver, BeforeAllCallback, AfterAllCallback {
    private val log = LoggerFactory.getLogger(BenchmarkTestExtension::class.java)
    private val contextNamespace = ExtensionContext.Namespace.create(BenchmarkExtension::class.java)
    private var internalCumulativeTime: Duration = Duration.ZERO

    private fun <T> measureInternalTime(call: ()->T) = measureTimedValue(call).let {
        internalCumulativeTime += it.duration
        it.value
    }

    override fun supportsParameter(parameterContext: ParameterContext, extensionContext: ExtensionContext): Boolean {
        return measureInternalTime {
            val type = parameterContext.parameter.type
            type == ExtensionContext::class.java ||
                    type == Metrics::class.java ||
                    type == TestClassCounters::class.java
        }
    }

    override fun resolveParameter(parameterContext: ParameterContext, extensionContext: ExtensionContext): Any {
        return measureInternalTime {
            when (parameterContext.parameter.type) {
                ExtensionContext::class.java -> extensionContext
                Metrics::class.java -> extensionContext.root.getStore(contextNamespace).get(Metrics::class.java)
                TestClassCounters::class.java -> extensionContext.getStore(contextNamespace)
                    .get(TestClassCounters::class.java)

                else -> throw RuntimeException("Unsupported parameter")
            }
        }
    }

    override fun beforeAll(context: ExtensionContext) {
        measureInternalTime {
            // clean all metrics in BenchmarkExtension produced by previous tests
            if (!context.testClass.get().isMemberClass) {
                internalCumulativeTime = Duration.ZERO
                Metrics.clear()
                val contextNamespace = ExtensionContext.Namespace.create(BenchmarkExtension::class.java)
                val store = context.root.getStore(contextNamespace)
                store.remove(TestClassCounters::class.java)
            }
        }
    }

    override fun afterAll(context: ExtensionContext) {
        if (context.testClass.get().isMemberClass) {
            return
        }
        log.trace { "After ALL. Internal cumulative time: $internalCumulativeTime [ms]" }
        val companion = context.testClass.get().kotlin.companionObject
        val instance = context.testClass.get().kotlin.companionObjectInstance
        companion?.members?.forEach { member ->
            if (member.findAnnotations(TestFinalization::class).isNotEmpty()) {
                if (member.valueParameters.size == 2) {
                    try {
                        member.call(
                            instance, Metrics,
                            context.getStore(contextNamespace).get(TestClassCounters::class.java)
                        )
                    } catch (ex: InvocationTargetException) {
                        log.error("Error while invoking @TestFinalization method", ex.cause)
                        ex.cause?.let { throw it }
                    }
                }
            }
        }
    }
}